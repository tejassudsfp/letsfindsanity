"""Session routes for writing sessions"""

from flask import Blueprint, request, jsonify
from middleware.auth_middleware import require_verified
from services.database import db
from services.claude_service import complete_analysis
from services.encryption_service import encrypt_content, decrypt_content

session_bp = Blueprint('session', __name__)


@session_bp.route('/start', methods=['POST'])
@require_verified
def start_session():
    """Start a writing session"""
    data = request.get_json()
    user_id = request.user['id']
    intent = data.get('intent')
    valid_intents = ["processing", "agreeing", "challenging", "solution", "venting", "advice", "reflecting"]
    if intent not in valid_intents:
        return jsonify({"error": "Invalid intent"}), 400

    # Create session (title will be auto-generated by AI)
    result = db.execute("""
        INSERT INTO sessions (user_id, intent, title, raw_content, ai_analysis, started_at)
        VALUES (%s, %s, '', '', '', NOW())
        RETURNING id, started_at
    """, [user_id, intent], commit=True)

    return jsonify({
        'session_id': str(result['id']),
        'started_at': result['started_at'].isoformat()
    }), 201


@session_bp.route('/<session_id>/autosave', methods=['PATCH'])
@require_verified
def autosave_session(session_id):
    """Autosave session content"""
    data = request.get_json()
    user_id = request.user['id']
    content = data.get('content', '')

    # Verify session belongs to user
    session = db.execute("""
        SELECT id FROM sessions
        WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Encrypt content before saving
    encrypted_content = encrypt_content(content)

    # Update content
    db.execute("""
        UPDATE sessions
        SET raw_content = %s
        WHERE id = %s
    """, [encrypted_content, session_id], commit=True)

    return jsonify({'success': True}), 200


@session_bp.route('/<session_id>/analyze', methods=['POST'])
@require_verified
def analyze_session(session_id):
    """Analyze writing with Claude"""
    data = request.get_json()
    user_id = request.user['id']
    content = data.get('content', '').strip()
    duration_seconds = data.get('duration_seconds', 0)
    linked_session_ids = data.get('linked_sessions', [])  # Array of session IDs to link

    if not content:
        return jsonify({'error': 'Content is required'}), 400

    # Verify session belongs to user
    session = db.execute("""
        SELECT intent FROM sessions
        WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Fetch linked sessions if any (max 2)
    linked_sessions = []
    limited_ids = []
    if linked_session_ids and len(linked_session_ids) > 0:
        # Limit to 2 previous sessions
        limited_ids = linked_session_ids[:2]

        linked_sessions_raw = db.execute("""
            SELECT id, title, raw_content, ai_analysis, topics, completed_at
            FROM sessions
            WHERE id = ANY(%s::uuid[]) AND user_id = %s AND completed_at IS NOT NULL
            ORDER BY completed_at DESC
        """, [limited_ids, user_id], fetch_all=True)

        # Decrypt linked sessions
        for s in linked_sessions_raw:
            linked_sessions.append({
                'title': s.get('title', 'untitled'),
                'content': decrypt_content(s['raw_content']) if s['raw_content'] else '',
                'topics': s.get('topics', []) or [],
                'completed_at': s['completed_at'].isoformat() if s['completed_at'] else None
            })

    # Fetch all historical topics from this user's previous sessions
    user_topics_result = db.execute("""
        SELECT DISTINCT unnest(topics) as topic
        FROM sessions
        WHERE user_id = %s AND topics IS NOT NULL AND array_length(topics, 1) > 0
        ORDER BY topic
    """, [user_id], fetch_all=True)

    user_historical_topics = [t['topic'] for t in user_topics_result] if user_topics_result else []

    # Get Claude analysis with linked sessions and historical topics
    analysis = complete_analysis(
        content,
        session['intent'],
        linked_sessions=linked_sessions,
        user_historical_topics=user_historical_topics
    )

    # Store safety check result, topics, and auto-generated title
    safety = analysis.get('safety_check', {})
    recommend_help = safety.get('recommend_professional_help', False)
    topics = safety.get('topics', [])
    journal_title = analysis.get('journal_title', 'untitled')

    # is_safe_for_sharing is based on the suggested_post being safe, not the original content
    suggested_post = analysis.get('suggested_post', {})
    is_safe_for_sharing = suggested_post.get('safe_to_publish', False)
    safety_notes = suggested_post.get('safety_notes', '')

    db.execute("""
        UPDATE sessions
        SET title = %s,
            is_safe_for_sharing = %s,
            safety_reason = %s,
            recommend_professional_help = %s,
            topics = %s,
            linked_sessions = %s::uuid[]
        WHERE id = %s
    """, [journal_title, is_safe_for_sharing, safety_notes if safety_notes else safety.get('reason', ''), recommend_help, topics, limited_ids if linked_session_ids else [], session_id], commit=True)

    return jsonify({
        'analysis': analysis
    }), 200


@session_bp.route('/<session_id>/save-private', methods=['POST'])
@require_verified
def save_private(session_id):
    """Save session privately (don't share)"""
    data = request.get_json()
    user_id = request.user['id']

    content = data.get('content', '').strip()
    title = data.get('title', '').strip()  # This comes from AI auto-generated journal_title
    ai_analysis = data.get('ai_analysis', '')
    duration_seconds = data.get('duration_seconds', 0)
    word_count = len(content.split()) if content else 0

    if not content:
        return jsonify({'error': 'Content is required'}), 400

    if not title:
        return jsonify({'error': 'Title is required'}), 400

    # Verify session belongs to user
    session = db.execute("""
        SELECT id FROM sessions
        WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Encrypt content before saving
    encrypted_content = encrypt_content(content)

    # Update session
    db.execute("""
        UPDATE sessions
        SET title = %s,
            raw_content = %s,
            ai_analysis = %s,
            duration_seconds = %s,
            word_count = %s,
            completed_at = NOW()
        WHERE id = %s
    """, [title, encrypted_content, ai_analysis, duration_seconds, word_count, session_id], commit=True)

    return jsonify({'success': True}), 200


@session_bp.route('/<session_id>/share', methods=['POST'])
@require_verified
def share_session(session_id):
    """Share session as public post"""
    from services.search_service import store_post_with_embedding

    data = request.get_json()
    user_id = request.user['id']
    three_word_id = request.user['three_word_id']

    original_content = data.get('original_content', '').strip()
    anonymized_content = data.get('anonymized_content', '').strip()
    clear_ask = data.get('clear_ask', '').strip()
    title = data.get('title', '').strip()
    topics = data.get('topics', [])
    ai_analysis = data.get('ai_analysis', '')

    if not original_content or not anonymized_content or not title:
        return jsonify({'error': 'Content and title are required'}), 400

    # Verify session belongs to user and check safety
    session = db.execute("""
        SELECT intent, is_safe_for_sharing, safety_reason
        FROM sessions
        WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Block sharing if marked unsafe
    if session.get('is_safe_for_sharing') == False:
        return jsonify({
            'error': 'This post was marked unsafe for sharing',
            'reason': session.get('safety_reason', 'Content did not pass safety check')
        }), 403

    # Save session privately first
    duration_seconds = data.get('duration_seconds', 0)
    word_count = len(original_content.split())

    # Encrypt content before saving
    encrypted_content = encrypt_content(original_content)

    db.execute("""
        UPDATE sessions
        SET raw_content = %s,
            ai_analysis = %s,
            duration_seconds = %s,
            word_count = %s,
            completed_at = NOW()
        WHERE id = %s
    """, [encrypted_content, ai_analysis, duration_seconds, word_count, session_id], commit=True)

    # Create public post with embedding and title
    post_data = {
        'user_id': user_id,
        'session_id': session_id,
        'three_word_id': three_word_id,
        'original_content': original_content,
        'anonymized_content': anonymized_content,
        'clear_ask': clear_ask,
        'title': title,
        'intent': session['intent'],
        'topics': topics
    }

    post_id = store_post_with_embedding(post_data)

    # AI analysis stays private in the journal, not added as a comment to the public post

    return jsonify({
        'success': True,
        'post_id': str(post_id)
    }), 201


@session_bp.route('/mine', methods=['GET'])
@require_verified
def get_my_sessions():
    """Get my private sessions with optional topic filtering"""
    user_id = request.user['id']
    page = int(request.args.get('page', 1))
    limit = int(request.args.get('limit', 20))
    offset = (page - 1) * limit
    topic_filter = request.args.get('topic', '').strip()

    # Build query with optional topic filter
    # Topics are now stored directly in sessions table
    # Show all completed sessions (even if published as posts)
    if topic_filter:
        sessions = db.execute("""
            SELECT s.id, s.intent, s.title, s.raw_content, s.ai_analysis, s.completed_at, s.topics,
                   p.id as post_id, p.three_word_id as post_three_word_id
            FROM sessions s
            LEFT JOIN posts p ON p.session_id = s.id
            WHERE s.user_id = %s AND s.completed_at IS NOT NULL AND (s.topics IS NULL OR %s = ANY(s.topics))
            ORDER BY s.completed_at DESC NULLS LAST
            LIMIT %s OFFSET %s
        """, [user_id, topic_filter, limit, offset], fetch_all=True)

        total_result = db.execute("""
            SELECT COUNT(*) as count
            FROM sessions s
            WHERE s.user_id = %s AND s.completed_at IS NOT NULL AND (s.topics IS NULL OR %s = ANY(s.topics))
        """, [user_id, topic_filter], fetch_one=True)
    else:
        sessions = db.execute("""
            SELECT s.id, s.intent, s.title, s.raw_content, s.ai_analysis, s.completed_at, s.topics,
                   p.id as post_id, p.three_word_id as post_three_word_id
            FROM sessions s
            LEFT JOIN posts p ON p.session_id = s.id
            WHERE s.user_id = %s AND s.completed_at IS NOT NULL
            ORDER BY s.completed_at DESC NULLS LAST
            LIMIT %s OFFSET %s
        """, [user_id, limit, offset], fetch_all=True)

        total_result = db.execute("""
            SELECT COUNT(*) as count
            FROM sessions s
            WHERE s.user_id = %s AND s.completed_at IS NOT NULL
        """, [user_id], fetch_one=True)

    total = total_result['count']

    return jsonify({
        'sessions': [
            {
                'id': str(s['id']),
                'intent': s['intent'],
                'title': s.get('title', 'untitled'),
                'raw_content': decrypt_content(s['raw_content']) if s['raw_content'] else '',
                'ai_analysis': s['ai_analysis'],
                'completed_at': s['completed_at'].isoformat() if s['completed_at'] else None,
                'topics': s.get('topics', []) or [],
                'post_id': str(s['post_id']) if s.get('post_id') else None,
                'post_three_word_id': s.get('post_three_word_id')
            }
            for s in sessions
        ],
        'total': total,
        'page': page,
        'pages': (total + limit - 1) // limit
    }), 200


@session_bp.route('/<session_id>', methods=['GET'])
@require_verified
def get_session(session_id):
    """Get a single session by ID"""
    user_id = request.user['id']

    session = db.execute("""
        SELECT s.id, s.intent, s.title, s.raw_content, s.ai_analysis, s.completed_at, s.topics,
               s.is_safe_for_sharing, s.safety_reason, s.duration_seconds, s.word_count,
               s.linked_sessions,
               p.id as post_id
        FROM sessions s
        LEFT JOIN posts p ON p.session_id = s.id
        WHERE s.id = %s AND s.user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Fetch linked session details if any
    linked_sessions_data = []
    if session.get('linked_sessions') and len(session['linked_sessions']) > 0:
        linked_sessions_raw = db.execute("""
            SELECT id, title, completed_at, word_count, topics
            FROM sessions
            WHERE id = ANY(%s::uuid[]) AND user_id = %s
            ORDER BY completed_at DESC
        """, [session['linked_sessions'], user_id], fetch_all=True)

        linked_sessions_data = [
            {
                'id': str(ls['id']),
                'title': ls.get('title', 'untitled'),
                'completed_at': ls['completed_at'].isoformat() if ls['completed_at'] else None,
                'word_count': ls.get('word_count', 0),
                'topics': ls.get('topics', []) or []
            }
            for ls in linked_sessions_raw
        ]

    return jsonify({
        'id': str(session['id']),
        'intent': session['intent'],
        'title': session.get('title', 'untitled'),
        'raw_content': decrypt_content(session['raw_content']) if session['raw_content'] else '',
        'ai_analysis': session['ai_analysis'],
        'completed_at': session['completed_at'].isoformat() if session['completed_at'] else None,
        'topics': session.get('topics', []) or [],
        'is_safe_for_sharing': session.get('is_safe_for_sharing'),
        'safety_reason': session.get('safety_reason'),
        'duration_seconds': session.get('duration_seconds', 0),
        'word_count': session.get('word_count', 0),
        'post_id': str(session['post_id']) if session['post_id'] else None,
        'linked_sessions': linked_sessions_data
    }), 200


@session_bp.route('/<session_id>', methods=['DELETE'])
@require_verified
def delete_session(session_id):
    """Delete a session and its associated post if any"""
    user_id = request.user['id']

    # Verify ownership
    session = db.execute("""
        SELECT id FROM sessions WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Delete will cascade to posts due to ON DELETE CASCADE
    db.execute("""
        DELETE FROM sessions WHERE id = %s
    """, [session_id], commit=True)

    return jsonify({'success': True}), 200


@session_bp.route('/<session_id>/edit', methods=['PATCH'])
@require_verified
def edit_session(session_id):
    """Edit an unanalyzed session's content"""
    user_id = request.user['id']
    data = request.get_json()
    content = data.get('content', '').strip()

    if not content:
        return jsonify({'error': 'Content is required'}), 400

    # Verify ownership and that session is not analyzed
    session = db.execute("""
        SELECT id, ai_analysis FROM sessions
        WHERE id = %s AND user_id = %s
    """, [session_id, user_id], fetch_one=True)

    if not session:
        return jsonify({'error': 'Session not found'}), 404

    # Only allow editing if not yet analyzed (ai_analysis is empty)
    if session.get('ai_analysis'):
        return jsonify({'error': 'Cannot edit analyzed sessions'}), 403

    # Encrypt content before saving
    encrypted_content = encrypt_content(content)

    # Update content
    db.execute("""
        UPDATE sessions
        SET raw_content = %s,
            word_count = %s
        WHERE id = %s
    """, [encrypted_content, len(content.split()), session_id], commit=True)

    return jsonify({'success': True}), 200


@session_bp.route('/search-for-linking', methods=['GET'])
@require_verified
def search_sessions_for_linking():
    """Search user's completed sessions for linking (by title or topics)"""
    user_id = request.user['id']
    query = request.args.get('q', '').strip().lower()
    limit = int(request.args.get('limit', 20))

    if not query:
        # Return recent sessions if no search query
        sessions = db.execute("""
            SELECT id, title, topics, completed_at, word_count
            FROM sessions
            WHERE user_id = %s AND completed_at IS NOT NULL
            ORDER BY completed_at DESC
            LIMIT %s
        """, [user_id, limit], fetch_all=True)
    else:
        # Search by title or topics
        sessions = db.execute("""
            SELECT id, title, topics, completed_at, word_count
            FROM sessions
            WHERE user_id = %s
                AND completed_at IS NOT NULL
                AND (
                    LOWER(title) LIKE %s
                    OR EXISTS (
                        SELECT 1 FROM unnest(topics) topic
                        WHERE LOWER(topic) LIKE %s
                    )
                )
            ORDER BY completed_at DESC
            LIMIT %s
        """, [user_id, f'%{query}%', f'%{query}%', limit], fetch_all=True)

    return jsonify({
        'sessions': [
            {
                'id': str(s['id']),
                'title': s.get('title', 'untitled'),
                'topics': s.get('topics', []) or [],
                'completed_at': s['completed_at'].isoformat() if s['completed_at'] else None,
                'word_count': s.get('word_count', 0)
            }
            for s in sessions
        ]
    }), 200
